CPU

平均负载： 系统处于可运行状态 R 和 不可中断状态 D 的平均进程数，跟CPU使用率没有直接关系
CPU使用率： 单位时间内CPU繁忙情况的统计，跟平均负载不一定对应。

CPU密集型进程
IO密集型进程    平均负载高 CPU使用率不一定高
存在大量等待CPU调度的进程

pidstat -u 5 1   查看进程占用CPU的情况  每隔5s刷新一次数据 输出一组
mpstat -P ALL 5 1 查看所有CPU的使用情况 
watch -d uptime

CPU上下文切换
将上一个任务的CPU上下文（CPU寄存器 跟 程序计数器）保存起来，然后加载新任务的上下文 

进程上下文切换
线程上下文切换  两种情况（是否同一个进程）
中断上下文切换 中断处理打断正常进程的正常调度和运行，响应设备事件  不涉及进程的上下文保存
vmstat 1 系统整体的CPU上下文切换 

pidstat -w 5  查看每个进程的上下文切换次数 
cswch 自愿上下文切换 进程无法获取资源（IO内存） 导致的上下文切换
nvcswch 非自愿上下文切换 进程由于时间片已到等原因，被系统强制调度切换。 比如大量进程在争取CPU时
pidstat -wt 查看线程的上下文切换次数

查看中断次数  cat /proc/interrupts
RES 重（chong）调度中断 这个中断类型表示唤醒空闲状态的CPU来调度新的任务运行

/proc/stat 系统CPU和任务的统计信息 
root@joedlut-virtual-machine:/home/joedlut# grep 'CONFIG_HZ=' /boot/config-5.19.0-45-generic 
CONFIG_HZ=250   每秒发生250次中断  

user 
nice  低优先级用户态CPU时间 1-19   nice 数值越大优先级越低   -20---19
system
idle （id） 空闲时间，不包括等待IO的时间
iowait (wa) 等待IO的CPU时间
irq (hi) 硬中断的时间
softirq (si) 软中断的时间
steal 被其他虚拟机占用CPU的时间

/proc/[pid]/stat 查看某个进程的CPU使用率 
注意： 性能分析工具给出的都是间隔一段时间的平均CPU使用率，要注意时间的设置，多个工具对比时，确保使用的相同的间隔时间 
top  按数字1 查看每个进程的CPU使用率  
ps 
pidstat -u  查看某个进程的用户态CPU使用率 跟 内核态CPU使用率
perf top 实时查看占用CPU时钟数最多的函数或者执行，查找热点函数   采样数需要我们特别注意，采样数过少没有意义
perf top -g -p pid 

perf record   -g  开启调用关系的采样
perr report 
-------------------------------------------------------
pstree | grep aaa  查看某个进程的父进程
execsnoop 是一个专门为短时进程设计的工具，通过ftrace监控进程的exec行为，输出短时进程的基本信息，包括进程PID，父进程PID，命令行参数一级执行的结果

top发现CPU使用率很高，但是pidstat -u 看不到占用CPU高的进程可能的原因
1. 应用直接调用了其他二进制程序，这些程序同样运行时间比较短，通过top工具不容易发现
2. 应用本身不断的在重启崩溃，启动过程的资源初始化，很可能占用相当多的CPU

pstree  |   execsnoop 
---------------------------------------------------------------
iowait升高，进程得不到硬件的响应，长时间处于不可中断状态  D 
R 进程正在运行，或者进程处在CPU的就绪队列中
D  
Z  Zombie 进程已经结束，但是父进程没有回收它的资源
S  可中断睡眠，进程因为等待某个时间被挂起，进程等待的时间发生，重新唤醒进入R状态
I  空闲状态，通常指不可中断的内核线程
T  STOP
X Dead

一个进程创建了子进程后，应该通过系统调用wait() 或者waitpid() 等待子进程结束，回收子进程的资源； 或者父进程注册SIGCHLD信号的处理函数，异步回收资源
大量的僵尸进程会用尽PID资源，导致新进程没法创建 

dstat  同时查看CPU跟 IO的使用情况 

You did not select any stats, using -cdngy by default.
--total-cpu-usage-- -dsk/total- -net/total- ---paging-- ---system--
usr sys idl wai stl| read  writ| recv  send|  in   out | int   csw 
  0   0 100   0   0|  47k   18k|   0     0 |   8B 1108B| 364   552 
  0   0  99   0   0|   0     0 | 120B  794B|   0     0 | 340   566 

pidstat -d -p pid 查看某个进程的IO使用情况
pidstat -d  查看所有进程的使用IO的情况
strace -p pid 

pstree -aps pid  |    -a 输出命令行选项 -s 表示进程的父进程

iowait 高并不一定代表IO有性能瓶颈，当系统只有IO类型的进程在运行时，iowait也会很高，但磁盘的读写实际上远没有达到性能瓶颈的程度 
------------------------------------------------------------------------------------
中断是一种异步的时间处理机制，可以提高系统的并发处理能力
为了减少对正常进程运行调度的影响，中断处理程序需要尽可能快的运行。
中断处理程序在响应中断时，还会临时关闭中断，导致上一次的中断处理完成之前，其他中断都不能被响应，中断可能会丢失

软中断

中断程序分为了上半部 跟 下半部
上半部用来快速处理中断，它在中断禁止模式下运行，主要处理跟硬件紧密相关或者时间敏感的工作 一般指的是硬中断，特点是快速执行
下半部用来延迟处理上半部未完成的工作，通常以内核线程的方式运行，每个CPU都对应一个软中断内核线程，ksoftirqd/CPU编号   指的是软中断，特点是延迟执行,一般包括网络收发，定时，调度，RCU锁等

/proc/softirqs 软中断的运行情况， 系统运行以来的累计中断次数 
/proc/interrupts 提供了硬中断的运行情况

root@joedlut-virtual-machine:/home/joedlut# cat /proc/softirqs 
                    CPU0       CPU1       CPU2       CPU3       
          HI:          0      59863          0          0
       TIMER:     141023     533686     208463     270909
      NET_TX:          0          0          4          5
      NET_RX:         71         40        196      87861
       BLOCK:      12875      13450      11733      18253
    IRQ_POLL:          0          0          0          0
     TASKLET:          0     239496          0        341
       SCHED:     419020     755519     388123     372010
     HRTIMER:          0          0          0          0
         RCU:     219999     247035     221996     207181


root@joedlut-virtual-machine:/home/joedlut# ps aux | grep ksoft
root          14  0.0  0.0      0     0 ?        S    6月17   0:00 [ksoftirqd/0]
root          23  0.0  0.0      0     0 ?        S    6月17   0:00 [ksoftirqd/1]
root          29  0.0  0.0      0     0 ?        S    6月17   0:00 [ksoftirqd/2]
root          35  0.0  0.0      0     0 ?        S    6月17   0:00 [ksoftirqd/3]
-------------------------------------------------------------------------------------------
软中断（比如网络收发的软中断）过多 导致CPU使用率过高

watch -d cat /proc/softirqs

sar 观察系统的网络收发情况
sar -n DEV 1  显示网络收发的报告
sar -u 1   CPU 
sar -r 1   内存

root@joedlut-virtual-machine:/home/joedlut# sar -n DEV 1
Linux 5.19.0-45-generic (joedlut-virtual-machine)       2023年06月18日  _x86_64_        (4 CPU)

00时25分09秒     IFACE   rxpck/s   txpck/s    rxkB/s    txkB/s   rxcmp/s   txcmp/s  rxmcst/s   %ifutil
00时25分10秒        lo      0.00      0.00      0.00      0.00      0.00      0.00      0.00      0.00
00时25分10秒     ens33      1.00      1.00      0.06      0.18      0.00      0.00      0.00      0.00
00时25分10秒   docker0      0.00      0.00      0.00      0.00      0.00      0.00      0.00      0.00

-------------------------------------------------------------------------------
CPU 性能优化

优化指标 
1. 应用程序的维度  吞吐量 请求延迟
2. 系统维度  CPU使用率

性能优化并非没有成本  带来复杂度的提升，降低程序的可维护性，优化一个指标，引发另外一个指标异常

应用程序优化 ：
1. 编译器优化  gcc -O2
2. 算法优化 复杂度更低的算法
3. 异步处理 避免程序因为等待一个资源而一直阻塞，提高程序的并发能力   轮询---> 时间通知
4. 多线程代替多进程  
5. 善用缓存


系统优化：
1.CPU绑定 把进程绑定到一个或者多个CPU上，提高CPU缓存的命中率，减少跨CPU带来的上下文切换
2. CPU独占，将CPU分组，通过CPU亲和性机制为其分配进程
3.优先级调整  nice值，适当调高核心应用的优先级，调低非核心应用的优先级
4. 为进程设置资源限制，使用linux cgroups设置进程的CPU使用上限，防止某个应用自身问题，耗尽系统资源
5. NUMA 
6. 中断负载均衡，开启irqbalance 服务或者配置 smp_affinity,将中断程序自动负载均衡到多个CPU上  

避免过早优化
1.优化带来复杂度的提升，降低可维护性
2.需求不断变化，针对当前情况做的优化，可能不能适应快速变化的新需求

最好逐步完善，动态进行，不追求一步到位，首先要保证能满足当前的性能要求 
